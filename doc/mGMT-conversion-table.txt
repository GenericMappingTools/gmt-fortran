$ Id: $

C STRUCTURES / FORTRAN DERIVED TYPES
int                 INTEGER(c_int)
unsigned int        INTEGER(c_int)              ... no unsigned ints in Fortran
size_t              INTEGER(c_size_t)
uint32_t            INTEGER(c_int32_t)
uint64_t            INTEGER(c_int64_t)
enum                INTEGER(c_int)              ... or INTEGER(KIND(some_enum_value))
float               REAL(c_float)
double              REAL(c_double)
double name[n]      REAL(c_double) name(0:n-1)
char name[n]        CHARACTER(n,c_char) name
char *              TYPE(c_ptr)
int *               TYPE(c_ptr)
float *             TYPE(c_ptr)
double *            TYPE(c_ptr)
enum *              TYPE(c_ptr)
struct *            TYPE(c_ptr)
struct type var[n]  ...                         ... test needed (GMT_PALETTE)
union *             TYPE(c_ptr)                 ... calls to c_loc, c_f_pointer on Fortran side
void *              TYPE(c_ptr)
double **           TYPE(c_ptr)
char * []           TYPE(c_ptr)
char **             TYPE(c_ptr)
struct **           TYPE(c_ptr)

C POINTER TO UNION / FORTRAN c_loc FUNCTION
C side:             union tU {int i; float x;};
                    void f(union tU *pu) {printf("int view: %d; float view: %f\n",pu->i,pu->x);};
Fortran side:       interface ; subroutine s(pu) bind(c,name='f') ; import c_ptr ; type(c_ptr),value :: pu ; end subroutine ; end interface
                    integer,target :: i ; real,target :: x ; i=1 ; call s(c_loc(i)) ; x=1.; call s(c_loc(x)) ; end program

FUNCTION NAMES
Fortran names (FUNCTION fname) case insensitive
C names (BIND(C,NAME='cname')) case sensitive

FUNCTION RETURN VALUES
void *              TYPE(c_ptr)
int                 INTEGER(c_int)
int64_t             INTEGER(c_int64_t)
double *            ...                         ... test needed (GMT_Get_Coord)

FUNCTION ARGUMENTS
void *              TYPE(c_ptr),VALUE
void **             TYPE(c_ptr)
int                 INTEGER(c_int),VALUE
unsigned int        INTEGER(c_int),VALUE        ... no unsigned ints in Fortran
int *               INTEGER(c_int) name         ... for scalar
int *               INTEGER(c_int) name(*)      ... for array
uint_64_t           INTEGER(c_int64_t)
float *, float []   REAL(c_float)               ... NULL as actual argument not allowed
                    TYPE(c_ptr),VALUE           ... NULL as actual argument allowed
double *, double [] REAL(c_double) name(*)      ... NULL as actual argument not allowed
                    TYPE(c_ptr),VALUE           ... NULL as actual argument allowed
char *              CHARACTER(1,c_char) name(*)
struct name         TYPE(name)                  ... for interoperable derived types
